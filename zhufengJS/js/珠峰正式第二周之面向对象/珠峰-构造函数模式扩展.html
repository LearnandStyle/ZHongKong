<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="ie=edge" />
	<title>Document</title>
</head>
<body>
	
	<script type="text/javascript">
//		function Fn(){
//			//this -> f1;
//			this.x = 100;
//			this.getX = function (){
//				//this ->需要看getX
//				console.log(this.x)
//			}
//		}
//		var f1 = new Fn;//1、在构造函数中new Fn（）执行，如果Fn不需要传递参数的话，后面的小括号可以省略
//		//2、this的问题：在类中出现的this.xxx = xxx中的this都是当前类的实例，而某一个属性值（方法），方法中的this需要看方法执行的时候，前面是否有‘.’才知道this是谁
//		
//		f1.getX();//方法中this是f1   ->100
//		var ss=f1.getX();
//		ss();//方法中this是window   ->undefined






//		function Fn(){
//	 		var num = 10;//私有变量
//			this.x = 100;//f1.x = 100;
//			this.getX = function (){//f1.getX = function(){}
//				console.log(this.x)
//			}
//		}
//		var f1 = new Fn;
//		console.log(f1.num)//undefined
//		//3、类有普通函数的一面，，当函数执行的时候，var num只是当前形成的私有作用域中的私有变量，他和f1这个实例没有任何关系；只有this.xxx= xxxx才相当于给f1这个实例增加私有属性和方法才和f1有关
//		function Fn(){
//			this.x = 100;
//			this.getX = function (){
//				console.log(this.x)
//			}
//			return {name:"zhufeng"};
//		}
//		var f1 = new Fn;
//		console.log(f1)//{name: "zhufeng"}
		/*4、浏览器在构造函数模式中，浏览器默认把实例返回（返回值是一个对象数据类型的值），
		     如果手动写了return返回，返回值是一个基本类型的值，当前实例值不变的，
		     例如：return 100；我们的f1还是当前Fn的实例。
		//返回的是一个引用类型的值,当前实例会被自己返回的值替换掉,
		例如return {name:"zhufeng"} f1就不再是Fn的实例了,而是对象{name:"zhufeng"};*/

		

//		function Fn(){
//			this.x = 100;
//			this.getX = function (){
//				console.log(this.x)
//			}
//			return {name:"zhufeng"};
//		}
//		var f1 = new Fn;
		/*
		 5、检测某个实例是否属于这个 类 -》instanceof
		 
		console.log(f1 instanceof Fn)//true
		console.log(f1 instanceof Array)//false
		console.log(f1 instanceof Object)//true   因为所有的实例都是对象数据类型的，而每一个对象数据类型都是object这个内置类的一个实例，所以f1也是他的一个实例
		//对于检测数据类型来说，typeof有自己的局限性，不能细分object下的对象数组和正则
		var a = [];
		console.log(a instanceof Array) //true 说明a是数组*/
		
		
		/*
		6、in:检测某一个属性是否属于这个对象(attr in object),不管私有属性还是公有属性,只要存在,用in来检测都是true
		function Fn(){
			this.x = 100;
			this.getX = function (){
				console.log(this.x)
			}
			return {name:"zhufeng"};
		}
		var f1 = new Fn;
		var f2 = new  Fn;
		f1  和f2都是这个类的一个实例,都拥有x和getX这两个属性,但是这两个属性是各自的私有属性,所以
		console.log('getX' in f1) //true  是他的一个属性
		
		//hasOwnProperty：检测某个属性是否是这个对象的‘私有属性’，这个只能检测私有属性
		console.log(f1.hasOwnProperty('getX'))  //true  'getX'是f1的私有属性
		
		思考：检测某个属性是否为该对象的‘共有属性’  hasPubProperty？
		function Fn(){
			this.x = 100;
			this.getX = function (){
				console.log(this.x)
			}
			return {name:"zhufeng"};
		}
		var f1 = new Fn;
		
		function hasPubProperty(obj,attr){
			//保证是他的属性并且不是私有属性
			return (attr in obj) &&  !obj.hasPubProperty(attr);
		}
		console.log(hasPubProperty(f1,'getX'))//false
		
		*/
		
//		7、isPrototypeof  看高程三或百度搜索找答案
		
			
	</script>
	
</body>

</html>