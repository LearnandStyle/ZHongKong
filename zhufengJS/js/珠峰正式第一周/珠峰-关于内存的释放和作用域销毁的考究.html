<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<div id="div1">就是不销毁，有本事点我啊</div>
		<script type="text/javascript">
			/*
			 堆内存释放：
			 对象数据类型或者函数数据类型在定义的时候都会开辟一个堆内存，堆内存有一个引用地址，如果外面有变量等知道了这个地址，就说这个内存被占用了，不能销毁内存
			 var obj1 = {name:'张三'};//xxxfff000
			 var obj2 = obj1;
			 //堆内存销毁/释放，只要把所有引用它的变量赋值为null即可，如果当前的堆内存没有任何东西被占用了，那么浏览器会在空闲的时候把它销毁  垃圾回收（手动优化前端行——
			 
			 obj1 = null；
			 obj2 = null;//null空对象指针
			 
			栈内存
			1）全局作用域    只有页面关闭的时候全局作用域才会销毁
			
			2）私有作用域（只有函数执行时会产生私有作用域）
			  一般情况下函数执行会形成一个私有作用域，当私有作用域中的代码执行完成后，我们当前的作用域会自动进行销毁和释放
			  但是还是存在特殊情况的：
			    当前私有作用域中的部分内存被作用域以外的东西占用了，那么当前的这个作用域就不能被销毁了
			 a、函数执行返回了一个引用类型的值，并且在函数外面被一个其他东西给接收了，这种情况下一般形式的私有作用域都不会被销毁
				 function(){
				 	var num = 100;
				 	return function(){
				 	}
				 }
				 var f = fn()//fn执行的这个私有作用域就不能被销毁了    不销毁条件：返回对象数据类型   被接收
			 
			 
			 b、在一个私有作用域中给DOM元素绑定事件方法，一般情况下私有作用域不销毁      oDiv1
			 c、下述情况属于不立即销毁->fn返回的函数没有被其他东西占用，但是还需要再执行一次，所以暂时不立即销毁，当返回的值执行完成后，浏览器会在空闲的时候把它销毁
				 function fn(){
				 	var num = 100;
				 	return function(){
				 		
				 	}
				 }
				 fn()()//首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			  
			 * */
			var oDiv = document.getElementById('div1');//通过DOM方法获取的元素/元素集合都是对象数据类型的值
			~function(){
				oDiv.onclick = function(){
					
				}
			}();//当前自执行函数形成的私有作用域也不销毁
		</script>
	</body>
</html>
